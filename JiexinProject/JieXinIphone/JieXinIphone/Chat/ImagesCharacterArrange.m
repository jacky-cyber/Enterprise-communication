////  ContentView.m//  talktalktalk////  Created by zuoxiaolin on 11-8-10.//  Copyright 2011 __MyCompanyName__. All rights reserved.//#import "ImagesCharacterArrange.h"#define EMOOFFSET 4 //表情图片的偏移量，使与文字水平居中对齐@implementation ImagesCharacterArrange@synthesize contentStrArr;@synthesize m_DrawWidth;@synthesize m_Name;@synthesize m_FontStyle;@synthesize m_EmoWidth;@synthesize m_RowHeigh;@synthesize m_FontSize;@synthesize m_Font;@synthesize m_EmoHeightOffset;- (id)initWithFrame:(CGRect)frame {        self = [super initWithFrame:frame];    if (self) {    }    return self;}/******************************************************************** 函数名称  : isEnglish 函数描述  : 判断是否为英文或特殊字符，用于换行判断 输入参数  : str 输出参数  : N/A 返回值    :BOOL 备注     : N/A *********************************************************************/-(BOOL)isEnglish:(NSString *)str {  /*	char c = [str characterAtIndex:0];	//如果是英文或特殊字符，返回YES	if (('a' <= c  && c<= 'z') || ('A' <= c  && c <= 'Z') 		|| c == ':' || c == '^' || c ==')' || c =='*') 	{		return TRUE;	}		return FALSE;	*/	char c = [str characterAtIndex:0];	//如果是英文或特殊字符，返回YES	if (('a' <= c  && c<= 'z') || ('A' <= c  && c <= 'Z') 		|| c == ':' || c == '{'|| c == '/'|| c == '*'||c == ';') 	{		return TRUE;	}		return FALSE;	}- (void)drawRect:(CGRect)rect {	//如果是主页的聊天记录显示，改变字体颜色深度，名字进行重绘，加深名字颜色	if (self.m_FontStyle == 1) {		//预览历史纪录		//[self.m_Name drawInRect:CGRectMake(0,EMOOFFSET, m_DrawWidth, m_RowHeigh) withFont:m_Font];		//[self.m_Name drawInRect:CGRectMake(0,EMOOFFSET, m_DrawWidth, m_RowHeigh) withFont:m_Font];		[[UIColor colorWithWhite:0.5 alpha:1]set];	}		//如果不是主页的聊天，不改变字体颜色深度，记录名字不进行重绘，加深名字颜色	if (self.m_FontStyle == 2)  {		//放大镜		[[UIColor colorWithRed:0.31 green:0.31 blue:0.31 alpha:1]set];		[self.m_Name drawInRect:CGRectMake(0,0, m_DrawWidth, m_RowHeigh) withFont:m_Font];		//[self.m_Name drawInRect:CGRectMake(0,0, m_DrawWidth, m_RowHeigh) withFont:m_Font];					}	if (self.m_FontStyle == 3) {		//聊天		[[UIColor colorWithRed:0.31 green:0.31 blue:0.31 alpha:1]set];	}	if (self.m_FontStyle == 4) {		//历史记录头		[[UIColor colorWithRed:0.65 green:0.65 blue:0.65 alpha:1]set];	}	if (self.m_FontStyle == 5) {		//历史记录头		[[UIColor whiteColor]set];	}    //循环绘制每一行的文字    	for (int i = 0; i < [self.contentStrArr count]; i++) 		{						NSString *temStr = [contentStrArr objectAtIndex:i];			//[temStr drawInRect:CGRectMake(0, i*m_RowHeigh+EMOOFFSET, m_DrawWidth, m_RowHeigh) withFont:m_Font];			if (self.m_FontStyle == 1 ) {				[temStr drawInRect:CGRectMake(0, i*m_RowHeigh+EMOOFFSET, m_DrawWidth, m_RowHeigh) withFont:m_Font];			}else if (m_FontStyle == 4) {				[temStr drawInRect:CGRectMake(0, i*m_RowHeigh, m_DrawWidth+20, m_RowHeigh) withFont:m_Font];			}else if (m_FontStyle == 3) {				[temStr drawInRect:CGRectMake(0, i*m_RowHeigh-1, m_DrawWidth+20, m_RowHeigh) withFont:m_Font];			}			else if (m_FontStyle == 5) {				[temStr drawInRect:CGRectMake(0, i*m_RowHeigh, m_DrawWidth+20, m_RowHeigh) withFont:m_Font];			}			else{				[temStr drawInRect:CGRectMake(0, i*m_RowHeigh, m_DrawWidth, m_RowHeigh) withFont:m_Font];						}					}	}/******************************************************************** 函数名称  : imagesCharactersArrange 函数描述  : 对传入的字符串进行处理，图文混排，得到混排好的视图 输入参数  : meg  maxWidth  name  sendfontStyle 输出参数  : N/A 返回值    : UIView 备注      : N/A *********************************************************************/-(UIView *)imagesCharactersArrange:(NSString *)meg maxWidth:(CGFloat)maxWidth peopleName:(NSString *)name fontStyle:(NSInteger)sendfontStyle {		if (meg == nil) {				return self;	}	//因为有大量的字符串处理，创建局部自动释放池，协助系统进行内存释放	NSAutoreleasePool *i_pool = [[NSAutoreleasePool alloc] init];    self.m_Name = name;	self.m_DrawWidth = maxWidth;	//文字显示的最大宽度	#define TEXTWIDTH maxWidth	//字符向前循环处理的最大字节数	#define WORDMAXLEN 8		//根据状态判断显示的自体大小，表情大小，行高	self.m_FontStyle = sendfontStyle;	//小字体，预览历史纪录	if (self.m_FontStyle == 1) {		self.m_EmoHeightOffset = 6;		self.m_RowHeigh = 17;//行高		self.m_FontSize = 7;//字体大小		self.m_EmoWidth = 7;//表情		self.m_Font = [UIFont fontWithName:@"Helvetica" size:m_FontSize];	}	if (self.m_FontStyle == 2){		//大字体，放大镜		self.m_RowHeigh = 17;//行高		self.m_FontSize = 14;//字体大小		self.m_EmoWidth = 17;//表情		self.m_Font = [UIFont fontWithName:@"Helvetica" size:m_FontSize];	}	if (self.m_FontStyle == 3){		//大字体，聊天界面		self.m_RowHeigh = 24;//行高		self.m_FontSize = 15;//字体大小		self.m_EmoWidth = 18;//表情		self.m_Font = [UIFont fontWithName:@"Helvetica" size:m_FontSize];	}	if (self.m_FontStyle == 4){		//大字体，历史纪录，头		self.m_RowHeigh = 17;//行高		self.m_FontSize = 13;//字体大小		self.m_EmoWidth = 17;//表情		self.m_Font = [UIFont fontWithName:@"Helvetica" size:m_FontSize];	}	if (self.m_FontStyle == 5){		//大字体，历史纪录，头		self.m_RowHeigh = 17;//行高		self.m_FontSize = 13;//字体大小		self.m_EmoWidth = 17;//表情		self.m_Font = [UIFont fontWithName:@"Helvetica" size:m_FontSize];	}    		NSString *VarText = nil ; //每次截取当前行后 剩下的的String  	NSMutableString *rowText = [NSMutableString string];//每一行的String  判断用	NSString *rowTextReal = [NSMutableString string];//每一行的String  最终显示用		NSMutableArray *rowStrArr =[NSMutableArray array];//行数组 用于存入所有 的行		NSMutableArray *emoArr = nil; //放表情的数组	NSMutableArray *emoLocationXArr = [NSMutableArray array];//放表情X组的数组	NSMutableArray *emoLocationYArr = [NSMutableArray array];//放表情Y组的数组	NSMutableArray *emoArrAndText = nil;//第一次处理后的返回值			NSInteger rowNum = 0;//行数			VarText = meg;		//VartText中的表情第一次处理：找到表情（转义字符串） ，并替换为 特定的统一转义字符串	emoArrAndText = [self replaceEmo:VarText];		//第一次处理后的表情	emoArr = [emoArrAndText objectAtIndex:0];	//第一次处理后字符串	VarText = [emoArrAndText objectAtIndex:1];		//循环遍历 每个字符	for (int i=0; i<[VarText length]; i++)	{				//取出每个字符			NSString *everyStr = [VarText substringWithRange:NSMakeRange(i, 1)];				//append到当前行中				[rowText appendString:everyStr];				//判断显示字体的状态		//算已经截取的字符的长度 			CGSize size = [rowText sizeWithFont:m_Font];				//得到每一行的最后一个字符 c 		//如果c为空格 直接可以换行 如果c不为空格 确定换行的位置后处理表情			if (size.width >= TEXTWIDTH)		{						//得到每一行的最后一个字符 c 			//如果c为空格换行,空格保留在这一行，不带入下一行			if ([everyStr isEqual:@" "])							{								rowTextReal = [rowText substringToIndex:i+1];				[rowStrArr addObject:rowTextReal];				VarText = [VarText substringFromIndex:i+1];							}//如果C不是英文，或者转移字符中的字符，换行，C带入到下一行			else if (![self isEnglish:everyStr]) {				rowTextReal = [rowText substringToIndex:i];				[rowStrArr addObject:rowTextReal];				VarText = [VarText substringFromIndex:i];			}																					//如果c不为空格 向前找 			else			{					 				//读取的次数，向前截取					int readCount = 0;												for (int m = [rowText length]-1; m >= 0; m--)				{											// 一行的最后 是几个连续的表情  的处理		(已经被简单化处理了 我手动加了空格）							//一行的最后 是一个很长的没有空格的 没有意义的字符串  //暂规定一个有意义的英文单词最大为 WORDMAXLEN  8个字符 					if (readCount > WORDMAXLEN) // 这是一个无意义的词，所以可以手动换行 从最后的字符C处换  相当直接换行					{													rowTextReal = [rowText substringToIndex:i];// 压线的C换到下一行						[rowStrArr addObject:rowTextReal];													VarText = [VarText substringFromIndex:i];															break;//结束当前截取					}										//找到第一个空格 换行						NSString *tempSpaceStr = [rowText substringWithRange:NSMakeRange(m, 1)];									if ([tempSpaceStr isEqualToString:@" "]) 					{												//空格前的string（要绘的）  要空格  判断表情时用																			rowTextReal = [rowText substringToIndex:m+1];						[rowStrArr addObject:rowTextReal];							//另起一行 不取空格  找表情时 特殊字符不包括前置空格						VarText = [VarText substringFromIndex:m+1];																			break;//结束当前截取					}					readCount ++;									}			}									//得到当前行中 表情的坐标			NSMutableArray *widthArr = 	[self findWidthArr:rowTextReal];						for (int n = 0; n < [widthArr count]; n++)			{				[emoLocationXArr  addObject:[widthArr objectAtIndex:n]];				NSString *high = [NSString stringWithFormat:@"%d",rowNum*m_RowHeigh];				[emoLocationYArr addObject:  high];			}						//如果是用作单行显示，只处理一行字符串			if (self.m_FontStyle == 4) {				[rowStrArr removeAllObjects];				rowTextReal = [rowTextReal stringByAppendingString:@"..."];				[rowStrArr addObject:rowTextReal];				break;			}						if (self.m_FontStyle == 5) {				[rowStrArr removeAllObjects];				rowTextReal = [rowTextReal stringByAppendingString:@"..."];				[rowStrArr addObject:rowTextReal];				break;			}			rowNum++;						//当前行已经换好  并且表情坐标也处理好  当前行的所有任务完成 将rowText 和 rowTextReal   i 清空			rowText =[NSMutableString string];			rowTextReal = [NSMutableString string];			i = -1;								}						//最后一行的处理		if ([VarText sizeWithFont:m_Font].width <= TEXTWIDTH) 				{			//处理 表情			NSMutableArray *widthArr = 	[self findWidthArr:VarText];			//得到当前行中 表情的坐标			for (int n = 0; n < [widthArr count]; n++)			{				[emoLocationXArr addObject:[widthArr objectAtIndex:n]];				NSString *high = [NSString stringWithFormat:@"%d",rowNum*m_RowHeigh];				[emoLocationYArr addObject:high];			}			[rowStrArr addObject:VarText];						rowNum++;			break;		}					}			//绘表情		for (int k = 0; k<[emoLocationXArr count]; k++)	{				NSString *imgName = [emoArr objectAtIndex:k];		UIImageView *img = [[UIImageView alloc]initWithImage:[UIImage imageNamed:imgName]];		//从数组中取出X Y坐标字符串，转化为float值				CGFloat x = [[emoLocationXArr objectAtIndex:k] floatValue];		CGFloat y = [[emoLocationYArr objectAtIndex:k] floatValue];		//确定表情frame		img.frame =CGRectMake(x,y+m_EmoHeightOffset,m_EmoWidth,m_EmoWidth);			//img.alpha = 0.2;		[self addSubview:img];		[img release];	}			//初始化一个数组，装新的字符	NSMutableArray *newStringArr = [[NSMutableArray alloc]init];	//把每一行字符中的转义字符替换成为空格	for (int k= 0; k<[rowStrArr count]; k++) {		NSString *tempstring = [rowStrArr objectAtIndex:k];		/************		NSRange rangeJudge = [tempstring rangeOfString:@"/:{ "];		 ****************/		//根据不同自体大小，采用不同的特殊字符		NSRange rangeJudge = NSMakeRange(0, 0);		if (m_FontSize == 7) {			rangeJudge = [tempstring rangeOfString:@"/;I"];		}		if (m_FontSize == 13) {			rangeJudge = [tempstring rangeOfString:@"/:{"];		}		if (m_FontSize == 14) {			rangeJudge = [tempstring rangeOfString:@"/;I"];		}		if (m_FontSize == 15) {			rangeJudge = [tempstring rangeOfString:@"/**"];		}		//如果有转义字符，就替换成空格		while (rangeJudge.length>0) 		{				/****************			NSRange range = [tempstring rangeOfString:@"/:{ "];			 *****************/			//根据不同自体大小，采用不同的特殊字符			NSRange range = NSMakeRange(0,0);			if (m_FontSize == 7) {				range = [tempstring rangeOfString:@"/;I"];			}			if (m_FontSize == 13) {				range = [tempstring rangeOfString:@"/:{"];			}			if (m_FontSize == 14) {				range = [tempstring rangeOfString:@"/;I"];			}			if (m_FontSize == 15) {				range = [tempstring rangeOfString:@"/**"];			}						rangeJudge = range;			//有表情			if (range.length > 0 ) 			{   //用新的特殊字符，替代原特殊字符，便于字符截取，判断坐标位置				/***************				tempstring = [tempstring stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																		   withString:@"    "];					 ***************/				//根据不同自体大小，采用不同的特殊字符				if (m_FontSize == 7) {					tempstring = [tempstring stringByReplacingCharactersInRange:NSMakeRange(range.location,3) 																	 withString:@"   "];					}				if (m_FontSize == 13) {					tempstring = [tempstring stringByReplacingCharactersInRange:NSMakeRange(range.location,3) 																	 withString:@"   "];					}				if (m_FontSize == 14) {					tempstring = [tempstring stringByReplacingCharactersInRange:NSMakeRange(range.location,3) 																	 withString:@"   "];					}				if (m_FontSize == 15) {					tempstring = [tempstring stringByReplacingCharactersInRange:NSMakeRange(range.location,3) 																	 withString:@"    "];					}															}					}		[newStringArr addObject:tempstring];	}		//self.contentStrArr = rowStrArr;	self.contentStrArr = newStringArr;	[newStringArr release];		//4表示只显示一行，跟其他显示方式frame定义方式区分开	if (m_FontStyle == 4) {		self.frame = CGRectMake(0, 0, TEXTWIDTH+EMOOFFSET+20, rowNum*m_RowHeigh);	}	else if (m_FontStyle == 5) {		self.frame = CGRectMake(0, 0, TEXTWIDTH+EMOOFFSET+20, rowNum*m_RowHeigh);	}	else if (m_FontStyle == 2) {		self.frame = CGRectMake(2, 0, TEXTWIDTH+EMOOFFSET, rowNum*m_RowHeigh);		}	else{		self.frame = CGRectMake(0, 0, TEXTWIDTH+EMOOFFSET, rowNum*m_RowHeigh);		}		[self setNeedsDisplay];			[i_pool release];		return self;	}/******************************************************************** 函数名称  : replaceEmo 函数描述  : 处理原始字符串，用特殊字符替换表情转义字符，得到表情数组，处理后的字符串 输入参数  : contentString 输出参数  : N/A 返回值    : NSMutableArray 备注     : N/A *********************************************************************///为了处理在每个转义字符串的换行的方便转义字符串前后加一个空格-(NSMutableArray *)replaceEmo:(NSString *)contentString{			NSMutableString *LastTest = [NSMutableString string];// 改为 特定的统一转义字符串 后的 最终string	NSMutableArray *emoArr = [NSMutableArray array]; //放表情的数组	NSMutableArray *emoArrAndText = [NSMutableArray array];//放入上面两个对象		//NSString *tempStr = nil	;	//	int i = 0; //0无表情  》0 有表情		NSString* text = contentString;	int length = text.length;		if (length<3) {				//先放表情 再放字符串  顺序和后面的保持一致 		[emoArrAndText addObject:emoArr];		[emoArrAndText addObject:contentString];				return emoArrAndText;	}		for(length;length>0;) 	{				length = text.length;				NSRange range = [text rangeOfString:@"/"];				if (range.length == 0) 		{			//已经没有了就跳出  			[LastTest appendString:text];			break;		}		else		{	//如果/的末尾不超过2个字符，没有表情，跳出			if (length-range.location < 3) {				[LastTest appendString:text];				break;			}			//当前 表情的 前面的 string				NSString *emojiString = [text substringWithRange:NSMakeRange(range.location,3)];			NSString *filePath = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"emotionImage.plist"];			NSDictionary *m_EmojiDic = [[NSDictionary alloc] initWithContentsOfFile:filePath];			NSString *i_transCharacter = [m_EmojiDic objectForKey:emojiString];						//如果有表情，替换掉，将表情名称存入数组			if (i_transCharacter) 			{				// 获取 表情 将表情（地址） 放入 数组				[emoArr addObject:i_transCharacter];								//将表情转义字符  改为统一的转义字符串				//根据不同自体大小，采用不同的特殊字符								if (m_FontSize == 7) {					text = [text stringByReplacingCharactersInRange:NSMakeRange(range.location, 3) 														 withString:@" /;I "];				}				if (m_FontSize == 13) {					text = [text stringByReplacingCharactersInRange:NSMakeRange(range.location, 3) 														 withString:@" /:{ "];				}				if (m_FontSize == 14) {					text = [text stringByReplacingCharactersInRange:NSMakeRange(range.location, 3) 														 withString:@" /;I "];				}				if (m_FontSize == 15) {					text = [text stringByReplacingCharactersInRange:NSMakeRange(range.location, 3) 														 withString:@" /** "];				}								/************				text = [text stringByReplacingCharactersInRange:NSMakeRange(range.location, 3) 													                     withString:@" /:{ "];					 ***************/				//封装 最后处理好的string 				[LastTest appendString:[text substringWithRange:NSMakeRange(0,range.location+5)]];				//剩下的string 				text = [text substringWithRange:NSMakeRange(range.location+5, text.length-range.location-5)];							}				else {				//封装 最后处理好的string 				[LastTest appendString:[text substringWithRange:NSMakeRange(0,range.location+1)]];				//剩下的string 				text = [text substringWithRange:NSMakeRange(range.location+1, text.length-range.location-1)];							}			[m_EmojiDic release];		}					}		//将存放所有表情名字的数组添加到emoArrAndText数组 	[emoArrAndText addObject:emoArr];	//将处理后的字符串添加到emoArrAndText数组 	[emoArrAndText addObject:LastTest];		return emoArrAndText;		}/******************************************************************** 函数名称  : findWidthArr 函数描述  : 获取每一行表情的坐标，存入坐标数组 输入参数  : textIneveryLine 输出参数  : N/A 返回值    : NSMutableArray 备注      : N/A *********************************************************************/-(NSMutableArray *)findWidthArr:(NSString *)textIneveryLine{		NSString *beforeEmo = nil;		NSMutableArray *xLocationArr = [NSMutableArray array];		int length = textIneveryLine.length;		if (length < 2) {		return xLocationArr;	}			//根据不同自体大小，采用不同的特殊字符	NSRange rangeJudge = NSMakeRange(0, 0);	if (m_FontSize == 7) {		rangeJudge = [textIneveryLine rangeOfString:@"/;I "];	}	if (m_FontSize == 13) {		rangeJudge = [textIneveryLine rangeOfString:@"/:{ "];	}	if (m_FontSize == 14) {		rangeJudge = [textIneveryLine rangeOfString:@"/;I "];	}	if (m_FontSize == 15) {		rangeJudge = [textIneveryLine rangeOfString:@"/** "];	}	/***********	NSRange rangeJudge = [textIneveryLine rangeOfString:@"/:{ "];	 ************/	// 循环遍历每一个表情	while (rangeJudge.length>0) 	{				// 得到 表情 在每一行中的位置   		// 得到 表情 在View中的位置 		/*************		NSRange range = [textIneveryLine rangeOfString:@"/:{ "];		*************/				//根据不同自体大小，采用不同的特殊字符		NSRange range = NSMakeRange(0,0);		if (m_FontSize == 7) {			range = [textIneveryLine rangeOfString:@"/;I "];		}		if (m_FontSize == 13) {			range = [textIneveryLine rangeOfString:@"/:{ "];		}		if (m_FontSize == 14) {			range = [textIneveryLine rangeOfString:@"/;I "];		}		if (m_FontSize == 15) {			range = [textIneveryLine rangeOfString:@"/** "];		}		//有表情		if (range.length > 0 ) 		{   //用新的特殊字符，替代原特殊字符，便于字符截取，判断坐标位置			/*************			textIneveryLine = [textIneveryLine stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																	   withString:@"/:( "];				 ***************/			if (m_FontSize == 7) {				textIneveryLine = [textIneveryLine stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																		   withString:@"/:! "];			}			if (m_FontSize == 13) {				textIneveryLine = [textIneveryLine stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																		   withString:@"/:( "];			}			if (m_FontSize == 14) {				textIneveryLine = [textIneveryLine stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																		   withString:@"/:! "];			}			if (m_FontSize == 15) {				textIneveryLine = [textIneveryLine stringByReplacingCharactersInRange:NSMakeRange(range.location,4) 																		   withString:@"*/* "];			}						beforeEmo = [textIneveryLine substringWithRange:NSMakeRange(0, range.location)];			CGFloat xLocation = [beforeEmo sizeWithFont:m_Font].width;			NSString *xlo = [NSString stringWithFormat:@"%f",xLocation];			[xLocationArr addObject:xlo];				rangeJudge = range;					}		// 没有表情		if(range.length <= 0)		{			return xLocationArr;		}			}		return xLocationArr;	}- (void)dealloc {	[contentStrArr release];	 	[m_Name release];    [super dealloc];}@end